!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):(e="undefined"!=typeof globalThis?globalThis:e||self)["joystick-node"]=r()}(this,(function(){"use strict";var e=e=>{throw new Error(`[joystick.validation] ${e}`)};const r=e=>!(!e||"object"!=typeof e||Array.isArray(e)),t=e=>!!Array.isArray(e),o=e=>"string"==typeof e;var s=(e,s)=>{switch(e){case"any":return(e=>!!e)(s);case"array":return t(s);case"boolean":return(e=>(!0===e||!1===e)&&"boolean"==typeof e)(s);case"float":return(e=>Number(e)===e&&e%1!=0)(s);case"integer":return(e=>Number(e)===e&&e%1==0)(s);case"number":return(e=>Number(e)===e)(s);case"object":return r(s);case"string":return o(s);default:return!1}};var n={types:["any","array","boolean","float","integer","number","object","string"],rules:{allowedValues:(e,r,t)=>e.includes(r)?{valid:!0,errors:[]}:{valid:!1,errors:[`Field ${t} only allows the following values: ${e.join(", ")}.`]},element:(e,s,n)=>{if(s&&(r(e)||o(e))&&t(s)){const t="test"===process.env.NODE_ENV?"../inputWithSchema":`${__dirname.replace(".joystick/build","node_modules/@joystick.js/node/dist/validation")}/inputWithSchema/index.js`,i=require(t),a=r(i)?i.default:i,l=[];return s.forEach(((r,t)=>{a(r,o(e)?{type:e}:e,`${n}.${t}`).forEach((e=>{l.push(e)}))})),{valid:0===l.length,errors:[...l]}}return{valid:!0,errors:[]}},fields:(e,t,o)=>{if(r(e)&&r(t)){const s="test"===process.env.NODE_ENV?"../inputWithSchema":`${__dirname.replace(".joystick/build","node_modules/@joystick.js/node/dist/validation")}/inputWithSchema/index.js`,n=require(s),i=(r(n)?n.default:n)(((e="")=>new RegExp(/\.[0-9]+\.?/g).test(e))(o)?t:{[o]:t},e,o);return{valid:0===i.length,errors:[...i]}}return{valid:!1,errors:[`${o} schema rule and input value for element must be of type object.`]}},max:(e,r,t)=>r<=e?{valid:!0,errors:[]}:{valid:!1,errors:[`${t} must be less than or equal to ${e}`]},min:(e,r,t)=>r>=e?{valid:!0,errors:[]}:{valid:!1,errors:[`${t} must be greater than or equal to ${e}`]},optional:(e,r,t)=>!1!==e||!!r?{valid:!0,errors:[]}:{valid:!1,errors:[`${t} is required`]},regex:(e,r,t)=>new RegExp(e).test(r)?{valid:!0,errors:[]}:{valid:!1,errors:[`${t} must conform to regex: ${e}`]},required:(e,r,t)=>!1===e||!!r?{valid:!0,errors:[]}:{valid:!1,errors:[`${t} is required`]},type:(e,r,t)=>{const o=s(e,r);return r&&!o?{valid:!1,errors:[`${t} must be of type ${e}`]}:{valid:!0,errors:[]}}}};const i=e=>{(e=>{Object.entries(e).forEach((([e,t])=>{if(!r(t))throw new Error(`Must pass an object containing rules to validate by for ${e} field.`)}))})(e),(e=>{Object.entries(e).forEach((([e,r])=>{Object.keys(r).forEach((r=>{if(!Object.keys(n.rules).includes(r))throw new Error(`Invalid rule name ${r} in rule for ${e} field.`)}))}))})(e),(e=>{Object.entries(e).forEach((([e,r])=>{if(r&&r.type&&!n.types.includes(r.type))throw new Error(`Invalid value for schema field "${e}" type rule. ${r.type} is not supported. Use one of the following: ${n.types.slice(0,n.types.length-1).join(", ")}, or ${n.types[n.types.length-1]}.`)}))})(e)};return(t=null)=>{t||e("Must pass schema object."),t&&!r(t)&&e("Must pass schema as an object."),i(t)}}));
