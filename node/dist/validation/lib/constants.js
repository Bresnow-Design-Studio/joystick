!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):(e="undefined"!=typeof globalThis?globalThis:e||self)["joystick-node"]=r()}(this,(function(){"use strict";const e=e=>!(!e||"object"!=typeof e||Array.isArray(e)),r=e=>!!Array.isArray(e),t=e=>"string"==typeof e;var o=(o,s)=>{switch(o){case"any":return(e=>!!e)(s);case"array":return r(s);case"boolean":return(e=>(!0===e||!1===e)&&"boolean"==typeof e)(s);case"float":return(e=>Number(e)===e&&e%1!=0)(s);case"integer":return(e=>Number(e)===e&&e%1==0)(s);case"number":return(e=>Number(e)===e)(s);case"object":return e(s);case"string":return t(s);default:return!1}};return{types:["any","array","boolean","float","integer","number","object","string"],rules:{allowedValues:(e,r,t)=>e.includes(r)?{valid:!0,errors:[]}:{valid:!1,errors:[`Field ${t} only allows the following values: ${e.join(", ")}.`]},element:(o,s,i)=>{if(s&&(e(o)||t(o))&&r(s)){const r="test"===process.env.NODE_ENV?"../inputWithSchema":`${__dirname.replace(".joystick/build","node_modules/@joystick.js/node/dist/validation")}/inputWithSchema/index.js`,n=require(r),a=e(n)?n.default:n,l=[];return s.forEach(((e,r)=>{a(e,t(o)?{type:o}:o,`${i}.${r}`).forEach((e=>{l.push(e)}))})),{valid:0===l.length,errors:[...l]}}return{valid:!0,errors:[]}},fields:(r,t,o)=>{if(e(r)&&e(t)){const s="test"===process.env.NODE_ENV?"../inputWithSchema":`${__dirname.replace(".joystick/build","node_modules/@joystick.js/node/dist/validation")}/inputWithSchema/index.js`,i=require(s),n=(e(i)?i.default:i)(((e="")=>new RegExp(/\.[0-9]+\.?/g).test(e))(o)?t:{[o]:t},r,o);return{valid:0===n.length,errors:[...n]}}return{valid:!1,errors:[`${o} schema rule and input value for element must be of type object.`]}},max:(e,r,t)=>r<=e?{valid:!0,errors:[]}:{valid:!1,errors:[`${t} must be less than or equal to ${e}`]},min:(e,r,t)=>r>=e?{valid:!0,errors:[]}:{valid:!1,errors:[`${t} must be greater than or equal to ${e}`]},optional:(e,r,t)=>!1!==e||!!r?{valid:!0,errors:[]}:{valid:!1,errors:[`${t} is required`]},regex:(e,r,t)=>new RegExp(e).test(r)?{valid:!0,errors:[]}:{valid:!1,errors:[`${t} must conform to regex: ${e}`]},required:(e,r,t)=>!1===e||!!r?{valid:!0,errors:[]}:{valid:!1,errors:[`${t} is required`]},type:(e,r,t)=>{const s=o(e,r);return r&&!s?{valid:!1,errors:[`${t} must be of type ${e}`]}:{valid:!0,errors:[]}}}}}));
