!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):(e="undefined"!=typeof globalThis?globalThis:e||self)["joystick-node"]=r()}(this,(function(){"use strict";var e=(e="")=>e.toLowerCase().replace(/\ /g,"-"),r=(e={},r=null)=>new Promise((async(t,n)=>{if("function"==typeof r){return t({...await r(e.req,e.res),req:e.req,res:e.res,...process.databases||{}})}return t({...r,req:e.req,res:e.res,...process.databases||{}})})),t=(e={})=>Object.getOwnPropertyNames(e).reduce(((r,t)=>(r[t]=e[t],r)),{}),n=(e={},r="")=>({error:t(e),message:e?.message||e?.reason||e,location:r}),s=e=>{throw new Error(`[joystick.validation] ${e}`)};const i=e=>!(!e||"object"!=typeof e||Array.isArray(e)),o=e=>!!Array.isArray(e),a=e=>"string"==typeof e;var l=(e,r)=>{switch(e){case"any":return(e=>!!e)(r);case"array":return o(r);case"boolean":return(e=>(!0===e||!1===e)&&"boolean"==typeof e)(r);case"float":return(e=>Number(e)===e&&e%1!=0)(r);case"integer":return(e=>Number(e)===e&&e%1==0)(r);case"number":return(e=>Number(e)===e)(r);case"object":return i(r);case"string":return a(r);default:return!1}},u=(e="")=>new RegExp(/\.[0-9]+\.?/g).test(e);var c={types:["any","array","boolean","float","integer","number","object","string"],rules:{allowedValues:(e,r,t)=>e.includes(r)?{valid:!0,errors:[]}:{valid:!1,errors:[`Field ${t} only allows the following values: ${e.join(", ")}.`]},element:(e,r,t)=>{if(r&&(i(e)||a(e))&&o(r)){const n="test"===process.env.NODE_ENV?"../inputWithSchema":`${__dirname.replace(".joystick/build","node_modules/@joystick.js/node/dist/validation")}/inputWithSchema/index.js`,s=require(n),o=i(s)?s.default:s,l=[];return r.forEach(((r,n)=>{o(r,a(e)?{type:e}:e,`${t}.${n}`).forEach((e=>{l.push(e)}))})),{valid:0===l.length,errors:[...l]}}return{valid:!0,errors:[]}},fields:(e,r,t)=>{if(i(e)&&i(r)){const n="test"===process.env.NODE_ENV?"../inputWithSchema":`${__dirname.replace(".joystick/build","node_modules/@joystick.js/node/dist/validation")}/inputWithSchema/index.js`,s=require(n),o=(i(s)?s.default:s)(u(t)?r:{[t]:r},e,t);return{valid:0===o.length,errors:[...o]}}return{valid:!1,errors:[`${t} schema rule and input value for element must be of type object.`]}},max:(e,r,t)=>r<=e?{valid:!0,errors:[]}:{valid:!1,errors:[`${t} must be less than or equal to ${e}`]},min:(e,r,t)=>r>=e?{valid:!0,errors:[]}:{valid:!1,errors:[`${t} must be greater than or equal to ${e}`]},optional:(e,r,t)=>!1!==e||!!r?{valid:!0,errors:[]}:{valid:!1,errors:[`${t} is required`]},regex:(e,r,t)=>new RegExp(e).test(r)?{valid:!0,errors:[]}:{valid:!1,errors:[`${t} must conform to regex: ${e}`]},required:(e,r,t)=>!1===e||!!r?{valid:!0,errors:[]}:{valid:!1,errors:[`${t} is required`]},type:(e,r,t)=>{const n=l(e,r);return r&&!n?{valid:!1,errors:[`${t} must be of type ${e}`]}:{valid:!0,errors:[]}}}};const d=e=>{(e=>{Object.entries(e).forEach((([e,r])=>{if(!i(r))throw new Error(`Must pass an object containing rules to validate by for ${e} field.`)}))})(e),(e=>{Object.entries(e).forEach((([e,r])=>{Object.keys(r).forEach((r=>{if(!Object.keys(c.rules).includes(r))throw new Error(`Invalid rule name ${r} in rule for ${e} field.`)}))}))})(e),(e=>{Object.entries(e).forEach((([e,r])=>{if(r&&r.type&&!c.types.includes(r.type))throw new Error(`Invalid value for schema field "${e}" type rule. ${r.type} is not supported. Use one of the following: ${c.types.slice(0,c.types.length-1).join(", ")}, or ${c.types[c.types.length-1]}.`)}))})(e)};var p=(e=null)=>{e||s("Must pass schema object."),e&&!i(e)&&s("Must pass schema as an object."),d(e)};const f=(e,r)=>{if(!r)return e;if(!e)return;const t=r.split(".");return f(e[t.shift()],t.join("."))},h=(e={},r="",t=!1)=>{if(t||!t&&!i(e))return e;if(r.includes(".$.")){const[t]=r.split(".$.");return f(e,t)}return f(e,r)},y=({queue:e,rules:r,input:t,path:n,rulesOnlySchema:s})=>{r&&"object"===r.type&&(e=m(e,r.properties,t,n)),r&&"array"===r.type&&i(r.element)&&(e=m(e,r.element,t,`${n}.$`));const o=u(n)?((e="")=>e.split(".").pop())(n):n;return{path:n,rules:r,inputValue:h(t,o,s)}},m=(e=[],r={},t={},n="")=>{const s=!!r.type;if(s||Object.entries(r).forEach((([r,i])=>{const o=y({queue:e,rules:i,input:t,path:`${n?`${n}.${r}`:r}`,rulesOnlySchema:s});e=[...e,o]})),s){const i=n||field,o=y({queue:e,rules:r,input:t,path:i,rulesOnlySchema:s});e=[...e,o]}return e},g=(e=null,r=null,t="")=>{const n=[];e||s("Must pass input."),r&&Object.keys(r)&&!r.type&&p(r);return m([],r,e,t).forEach((e=>{Object.entries(e.rules).forEach((async([r,t])=>{const s=c.rules[r];if(s&&!e.path.includes(".$.")){const r=s(t,e.inputValue,e.path);r&&!r.valid&&r.errors.forEach((e=>{n.push(e.includes("Field ")?e:`Field ${e}.`)}))}}))})),n},b=(e={},r=[])=>(Object.entries(e).forEach((([t,n])=>{const s=r.find((e=>e.key===t));return s||delete e[t],s&&i(n)&&0===s.children.length?n:s&&i(n)&&s.children.length>0?b(n,s.children):void(s&&Array.isArray(n)&&s.children&&s.children.length>0&&n.forEach((e=>{if(e&&i(e))return b(e,s.children)})))})),e),v=(e=[])=>{const[r,...t]=e;return{head:r,tail:t}},$=(e=[],r=[])=>(r.forEach((r=>{const t=e.find((e=>e.key===r.head));if(!t){const t=r.tail&&r.tail.length>0?v(r.tail):null;e.push({key:r.head,children:t?$([],[t]):[]})}if(t){const e=r.tail&&r.tail.length>0?v(r.tail):null;t.children=[...e?$(t.children,[e]):[]]}})),e);var j=(e={},r=[])=>{const t=[],n=((e=[])=>e.map((e=>v(e))))(((e=[])=>e.map((e=>e.split("."))))(r));return $(t,n),b(e,t)};return(t,s=[],i={})=>{const{app:o}=t;if(o)for(const[t,a]of s)o.get(`/api/_getters/${e(t)}`,(async(e,t)=>{const s=await r({req:e,res:t},i),{query:o}=e,l=o?.input?JSON.parse(o?.input):null,u=o?.output?JSON.parse(o?.output):null,c=a?.get;let d=[];if(a?.input&&(d=g(l,a.input)),c&&"function"==typeof c&&0===d.length)try{const e=await c(l,s)||{},r=u?j(e,u):e;return t.send(JSON.stringify(r||{}))}catch(e){return console.log(e),t.status(500).send(JSON.stringify({errors:[n(e,"server")]}))}if(d.length>0)return console.log(d),t.status(400).send(JSON.stringify({errors:d.map((e=>n(new Error(e,"validation"))))}));t.status(200).send(JSON.stringify({errors:[]}))}))}}));
